\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{palatino} 
\usepackage{xcolor}
\definecolor{lightgrey}{gray}{0.8}
\usepackage{listingsutf8}
\lstset
{ language=java
, captionpos=b
%, frame=lines
, morekeywords={var,get,set}
, basicstyle=\footnotesize\ttfamily
, keywordstyle=\color{blue}
, commentstyle=\color{green}
, stringstyle=\color{red}
, numbers=left
, numberstyle=\scriptsize
, stepnumber=2
, numbersep=5pt
, breaklines=true
, tabsize=2
, showstringspaces=false
, emph={double,bool,int,unsigned,char,true,false,void,get,set}
, emphstyle=\color{blue}
, emph={Assert,Test}
, emphstyle=\color{red}
, emph={[2]\#using,\#define,\#ifdef,\#endif}
, emphstyle={[2]\color{blue}}
, frame=single
, rulesepcolor=\color{lightgrey}
, lineskip={-1.5pt} % single line spacing
}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\title{SINF1121 - Groupe 9\\Rapport 1}
\author{\\Gégo Anthony\\ Gena Xavier \\Joveneau Quentin\\Libioulle Thibault \\Moyaux Arnold\\ Naveau Adrien \\ Payen Marlon}
\def\blurb{\textsc{Université catholique de Louvain\\
  École polytechnique de Louvain}}
\def\clap#1{\hbox to 0pt{\hss #1\hss}}%
\def\ligne#1{%
  \hbox to \hsize{%
    \vbox{\centering #1}}}%
\def\haut#1#2#3{%
  \hbox to \hsize{%
    \rlap{\vtop{\raggedright #1}}%
    \hss
    \clap{\vbox{\vfill\centering #2\vfill}}%
    \hss
    \llap{\vtop{\raggedleft #3}}}}%
\begin{document}
\begin{titlepage}
\thispagestyle{empty}\vbox to 1\vsize{%
  \vss
  \vbox to 1\vsize{%
    \haut{\includegraphics[scale=0.15]{logo_ucl.pdf}}{\blurb}{\includegraphics[scale=0.4]{logo_epl.jpg}}
    \vfill
    \ligne{\Huge \textbf{\textsc{Structures de données\\ et algorithmes (SINF1121)}}}
    \vspace{5mm}
    \ligne{\Large \textbf{Mission 1 - Réponses aux questions}}
    \vspace{5mm}
    \ligne{\large{-- 25 septembre 2013 --}}
    %\begin{center}\includegraphics[scale=3]{img/img_couverture.png}\end{center}
    \vfill
    \ligne{%
      \begin{tabular}{c}
        \textsc{Travail du groupe 9 :}
      \end{tabular}}
    \vspace{5mm}
    \ligne{%
      \begin{tabular}{lrclr}
         \textsc{Gégo} Anthony  & 28581100 & \hspace{80pt} & \textsc{Moyau} Arnold & xxxxxx00\\
         \textsc{Gena} Xavier  & xxxxxx00 & & \textsc{Naveau} Adrien & xxxxxx00\\
         \textsc{Joveneau} Quentin & xxxxxx00  & & \textsc{Payen} Marlon & xxxxxx00\\
         \textsc{Libioulle} Thibault & 60271100  & &  & 
      \end{tabular}
      }
    }%
  \vss
  }
\end{titlepage}

\section{Question 1}
\begin{quotation}
\textit{Définissez ce qu’est un type abstrait de données (TAD). En Java, est-il préférable de décrire un TAD par une classe ou une interface ? Pourquoi ?}
\end{quotation}

Un type abstrait de données est un modèle mathématique d'une structure de données spécifiant le type d'informations stockées, les opérations supportées sur ces dernières, ainsi que les types de paramètres des opérations. Un TAD spécifie ce que chaque opération fait, mais pas comment elle le fait. 

De ce fait, en Java, un TAD peut être décrit au moyen d'une interface, puisqu'elle ne consiste qu'en une liste de déclarations de méthodes sans implémentation.

\section{Question 2} 
\begin{quotation}
\textit{Comment faire pour implémenter une pile par une liste simplement chaînée où les
opérations push et pop se font en fin de liste ? Cette solution est-elle efficace ?
Argumentez.}
\end{quotation}

L'essentiel est de maintenir une référence vers l'objet en fin de liste. Chaque nœud possède alors une référence vers l'élément contenu ainsi que vers le nœud qui le précède.

L'opération push se réalisera, quelque soit la taille de la pile, en un nombre constant d'opérations. Il suffit en effet que de lié le nouveau nœud à l'actuel dernier, et de modifier la référence pointant vers le dernier nœud vers le nouveau. Un raisonnement similaire peut être appliqué pour l'opération pop qui consiste à enlever le dernier nœud et modifier la référence du dernier nœud vers le précédent.

Au vu de ce raisonnement, nous pouvons conclure que la solution sera tout aussi efficace que si l'opération était effectuée en début de liste.

\section{Question 3}
\begin{quotation}
\textit{En consultant la documentation sur l’API de Java, décrivez l’implémentation
d’une pile par la classe java.util.Stack. Cette classe peut-elle convenir
comme implémentation de l’interface Stack décrite dans DSAJ-5 ? Pourquoi ?}
\end{quotation}

La classe java.util.Stack étend la classe Vector à laquelle sont ajoutées les opérations nécessaires pour être utilisable comme pile. Un Vector est un tableau qui est redimensionné dynamiquement en fonction des besoins. Si, d'un point de vue, la complexité spatiale peut être réduite car il n'est pas nécessaire de retenir les références vers les noeuds suivants, il ne faut cependant pas négliger les opérations nécessaire pour la réallocation du tableau à chaque redimensionnement. 

Puisque l'interface est complètement indépendante de l'implémentation et que les méthodes push et pop sont définies, la classe peut ainsi servir d'implémentation de l'interface Stack décrite dans le livre de référence.

\section{Question 4}
\begin{quotation}
\textit{Proposez une implémentation de la classe DNodeStack. Il s’agit d’une classe
similaire à NodeStack (décrite dans DSAJ-5) qui propose une implémentation
générique d’une pile. Votre classe DNodeStack doit utiliser une implémentation en liste doublement chaînée générique. Elle reposera donc sur une classe
DNode<E> (similaire à Node<E>, décrite dans DSAJ-5) que vous devez définir.
Ajoutez, dans la classe DNodeStack, une méthode public String toString()
qui renvoie une chaîne de caractères représentant le contenu de la pile. Commentez votre code.}
\end{quotation}

\lstinputlisting[caption=DNode.java]{question4/DNode.java}
\lstinputlisting[caption=Stack.java]{question4/Stack.java}
\lstinputlisting[caption=DNodeStack.java]{question4/DNodeStack.java}
\lstinputlisting[caption=EmptyStackException.java]{question4/EmptyStackException.java}

\section{Question 5}
\begin{quotation}
\textit{Complétez l'interface Queue (décrite dans DSAJ-5) contenant une interface pour le type abstrait file en ajoutant des préconditions et postconditions pour chacune des méthodes. Votre spécification correspond-elle à une programmation défensive ?}
\end{quotation}

\lstinputlisting[caption=Queue.java]{question5/Queue.java}
\lstinputlisting[caption=EmptyQueueException.java]{question5/EmptyQueueException.java}

Ajouter des préconditions à une méthode signifie que cette dernière est prévue pour fonctionner correctement si et seulement si les préconditions sont respectées. Dès lors, à partir du moment où l'on néglige de vérifier l'entrée, on ne peut pas parler de programmation défensive. En effet, spécifier des préconditions n'empêche en rien à l'utilisateur de passer des paramètres n'y répondant pas.

\section{Question 6}
\begin{quotation}
\textit{Comment faire pour implémenter le type abstrait de données File à l’aide de
deux piles ? Décrivez en particulier le fonctionnement des méthodes enqueue et
dequeue dans ce cas. A titre d’exemple, précisez l’état de chacune des deux piles
après avoir inséré les entiers 1 2 3 à partir d’une file initialement vide. Décrivez
ce qu’il se passe ensuite lorsque l’on effectue l’opération dequeue. Quelle est
la complexité temporelle de ces méthodes si l’on suppose que chaque opération
pop et push s’exécute en temps constant. Cette implémentation d’une file est-elle efficace par rapport aux autres implémentations présentées dans DSAJ-5 ?}
\end{quotation}

Le but de cette première manipulation est que le premier élément insérer (\textbf{enqueue}) soit le premier à sortir (\textbf{dequeue}), on appelle ce principe \underline{FIFO}. Prenons deux piles que nous nommons \textit{entrée} et \textit{sortie}, lorsque nous utilisons la méthode \textbf{enqueue}, nous faisons un \textbf{push} dans \textit{entrée}. Ensuite, si nous utilisons \textbf{dequeue} :
\begin{itemize}
\item Nous devons vérifier si \textit{sortie} est vide. Si oui, on utilise la méthode \textbf{push} de \textit{sortie} avec comme argument le résultat du \textbf{pop} sur \textit{entrée};
\item On utilise la méthode \textbf{pop} sur \textit{sortie} et on retourne le résultat.
\end{itemize}
L'action réalisée lorsque \textit{sortie} est vide a pour but d'inverser le sens de la pile \textit{entrée}. Comme cela, le premier élément insérer dans \textit{entrée} sera le dernier élément insérer dans \textit{sortie} et donc le premier à sortir. Un exemple est donné dans la figure \ref{ex6}.
\begin{figure}[!h]
\begin{center}
\begin{tabular}{|c|c|c|c|}
\hline
Étape&\textit{entrée}&\textit{sortie}&Résultat\\
\hline
Départ&3 2 1& (vide) & /\\
\hline
Dequeue&(vide)&2 3& 1\\
\hline
\end{tabular}
\end{center}
\caption{Exemple de file implémentée avec deux piles}
\label{ex6}
\end{figure}

Au niveau de la complexité temporelle, celle de \textbf{enqueue} reste $O(1)$, puisqu'on utilise juste un \textbf{push}. Par contre si \textit{sortie} est vide, \textbf{dequeue} a une complexité de $2n+1$ opération puisqu'on opère $n$ \textbf{push} sur \textit{sortie}, $n$ \textbf{pop} sur \textit{entrée} et 1 \textbf{pop} sur \textit{sortie}(ce cas est le pire cas possible). On peut simplifier en disant que cette complexité temporelle est $O(n)$.

Par rapport à l'implémetation proposée dans DSAJ-5, cette implémentation n'est pas efficace puisque la complexité de \textbf{dequeue} est $O(n)$ dans ce cas et $O(1)$ dans le livre.

\section{Question 7}
\begin{quotation}
\textit{Comment faire en Java pour lire des données textuelles depuis un fichier et pour
écrire des résultats dans un fichier ASCII ? Écrivez en Java une méthode générique,
c’est-à-dire aussi indépendante que possible de son utilisation dans un contexte
particulier, de lecture depuis un fichier texte. Faites de même pour l’écriture dans
un fichier ASCII.}
\end{quotation}
\lstinputlisting[caption=FileRW.java]{question7/FileRW.java}

\section{Question 8}
\begin{quotation}
\textit{Comment faire en Java pour passer des arguments à un programme ? Soyez précis.
Donnez un exemple illustrant l’intérêt de cette opération.}
\end{quotation}
Quand on écrit notre programme, nous passons par une classe « main » pour instancier nos classes et réaliser le traitement adéquat. Nous pouvons attribuer à cette classe « main » un tableau composé des arguments de notre choix sous le format « String ». Si nous voulons utiliser un autre type, nous pouvons passer par des parseurs.

Ces arguments seront précisés après la compilation, c’est-à-dire lors de l’exécution du programme. Pour cela, via l’interprète de commande, nous écrivons l’instruction « java », suivi le nom du fichier contenant la classe « main » ainsi que le(s) argument(s) que vous voulez passer au programme.
\subsection*{Exemple}
\lstinputlisting[caption=Carre.java]{question8/Carre.java}
\lstinputlisting[caption=TestCarre.java]{question8/TestCarre.java}
\begin{lstlisting}[caption=Compilation]
javac TestCarre.java
\end{lstlisting}
\begin{lstlisting}[caption=Exécution (3.5 correspond à l’argument que l’on passe au programme)]
java TestCarre 3.5
\end{lstlisting}
\end{document}
